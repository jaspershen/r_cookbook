[
["multiomics.html", "Chapter 7 多组学分析 7.1 WGCNA", " Chapter 7 多组学分析 7.1 WGCNA 使用官方例子进行学习. https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/ 7.1.1 Data input and cleaning 首先读取数据 library(WGCNA) femData &lt;- read.csv(&quot;/Users/shenxt/study/WGCNA_test/LiverFemale3600.csv&quot;) dim(femData) ## [1] 3600 143 colnames(femData) ## [1] &quot;substanceBXH&quot; &quot;gene_symbol&quot; &quot;LocusLinkID&quot; &quot;ProteomeID&quot; &quot;cytogeneticLoc&quot; &quot;CHROMOSOME&quot; ## [7] &quot;StartPosition&quot; &quot;EndPosition&quot; &quot;F2_2&quot; &quot;F2_3&quot; &quot;F2_14&quot; &quot;F2_15&quot; ## [13] &quot;F2_19&quot; &quot;F2_20&quot; &quot;F2_23&quot; &quot;F2_24&quot; &quot;F2_26&quot; &quot;F2_37&quot; ## [19] &quot;F2_42&quot; &quot;F2_43&quot; &quot;F2_45&quot; &quot;F2_46&quot; &quot;F2_47&quot; &quot;F2_48&quot; ## [25] &quot;F2_51&quot; &quot;F2_52&quot; &quot;F2_54&quot; &quot;F2_63&quot; &quot;F2_65&quot; &quot;F2_66&quot; ## [31] &quot;F2_68&quot; &quot;F2_69&quot; &quot;F2_70&quot; &quot;F2_71&quot; &quot;F2_72&quot; &quot;F2_78&quot; ## [37] &quot;F2_79&quot; &quot;F2_80&quot; &quot;F2_81&quot; &quot;F2_83&quot; &quot;F2_86&quot; &quot;F2_87&quot; ## [43] &quot;F2_88&quot; &quot;F2_89&quot; &quot;F2_107&quot; &quot;F2_108&quot; &quot;F2_109&quot; &quot;F2_110&quot; ## [49] &quot;F2_111&quot; &quot;F2_112&quot; &quot;F2_117&quot; &quot;F2_119&quot; &quot;F2_125&quot; &quot;F2_126&quot; ## [55] &quot;F2_127&quot; &quot;F2_141&quot; &quot;F2_142&quot; &quot;F2_143&quot; &quot;F2_144&quot; &quot;F2_145&quot; ## [61] &quot;F2_154&quot; &quot;F2_155&quot; &quot;F2_156&quot; &quot;F2_157&quot; &quot;F2_162&quot; &quot;F2_163&quot; ## [67] &quot;F2_164&quot; &quot;F2_165&quot; &quot;F2_166&quot; &quot;F2_167&quot; &quot;F2_169&quot; &quot;F2_180&quot; ## [73] &quot;F2_181&quot; &quot;F2_182&quot; &quot;F2_187&quot; &quot;F2_188&quot; &quot;F2_189&quot; &quot;F2_190&quot; ## [79] &quot;F2_191&quot; &quot;F2_192&quot; &quot;F2_194&quot; &quot;F2_195&quot; &quot;F2_200&quot; &quot;F2_201&quot; ## [85] &quot;F2_212&quot; &quot;F2_213&quot; &quot;F2_214&quot; &quot;F2_215&quot; &quot;F2_221&quot; &quot;F2_222&quot; ## [91] &quot;F2_223&quot; &quot;F2_224&quot; &quot;F2_225&quot; &quot;F2_226&quot; &quot;F2_227&quot; &quot;F2_228&quot; ## [97] &quot;F2_241&quot; &quot;F2_242&quot; &quot;F2_243&quot; &quot;F2_244&quot; &quot;F2_245&quot; &quot;F2_247&quot; ## [103] &quot;F2_248&quot; &quot;F2_261&quot; &quot;F2_263&quot; &quot;F2_264&quot; &quot;F2_270&quot; &quot;F2_271&quot; ## [109] &quot;F2_272&quot; &quot;F2_278&quot; &quot;F2_287&quot; &quot;F2_288&quot; &quot;F2_289&quot; &quot;F2_290&quot; ## [115] &quot;F2_291&quot; &quot;F2_296&quot; &quot;F2_298&quot; &quot;F2_299&quot; &quot;F2_300&quot; &quot;F2_302&quot; ## [121] &quot;F2_303&quot; &quot;F2_304&quot; &quot;F2_305&quot; &quot;F2_306&quot; &quot;F2_307&quot; &quot;F2_308&quot; ## [127] &quot;F2_309&quot; &quot;F2_310&quot; &quot;F2_311&quot; &quot;F2_312&quot; &quot;F2_320&quot; &quot;F2_321&quot; ## [133] &quot;F2_323&quot; &quot;F2_324&quot; &quot;F2_325&quot; &quot;F2_326&quot; &quot;F2_327&quot; &quot;F2_328&quot; ## [139] &quot;F2_329&quot; &quot;F2_330&quot; &quot;F2_332&quot; &quot;F2_355&quot; &quot;F2_357&quot; 可以看到该数据行是基因,列是样品. 然后将基因的描述列去掉.并且将其转置,行是样品,列是基因. data_exp0 &lt;- as.data.frame(t(femData[, -c(1:8)]), stringsAsFactors = FALSE) names(data_exp0) = femData$substanceBXH rownames(data_exp0) = names(femData)[-c(1:8)] 然后需要去除掉数据(表达矩阵)中的outlier基因和样品 gsg &lt;- goodSamplesGenes(data_exp0, verbose = 3) ## Flagging genes and samples with too many missing values... ## ..step 1 gsg$allOK ## [1] TRUE 该函数用来检查数据中的基因是否符合要求,如果allOK为TRUE,则代表通过检查,如果不是TRUE,则需要手动去除基因和样品: if (!gsg$allOK) { # Optionally, print the gene and sample names that were removed: if (sum(!gsg$goodGenes) &gt; 0) printFlush(paste(&quot;Removing genes:&quot;, paste(names(data_exp0)[!gsg$goodGenes], collapse = &quot;, &quot;))) if (sum(!gsg$goodSamples) &gt; 0) printFlush(paste(&quot;Removing samples:&quot;, paste(rownames(data_exp0)[!gsg$goodSamples], collapse = &quot;, &quot;))) # Remove the offending genes and samples from the data: data_exp0 &lt;- data_exp0[gsg$goodSamples, gsg$goodGenes] } 现在下面对样品进行聚类,然后观察有哪些明显的outlier samples. sampleTree &lt;- hclust(dist(data_exp0), method = &quot;average&quot;) # Plot the sample tree: Open a graphic output window of size 12 by 9 inches # The user should change the dimensions if the window is too large or too small. sizeGrWindow(12, 9) #pdf(file = &quot;Plots/sampleClustering.pdf&quot;, width = 12, height = 9); par(cex = 0.6) par(mar = c(0, 4, 2, 0)) plot( sampleTree, main = &quot;Sample clustering to detect outliers&quot;, sub = &quot;&quot;, xlab = &quot;&quot;, cex.lab = 1.5, cex.axis = 1.5, cex.main = 2 ) # Plot a line to show the cut abline(h = 15, col = &quot;red&quot;) # Determine cluster under the line clust = cutreeStatic(sampleTree, cutHeight = 15, minSize = 10) table(clust) ## clust ## 0 1 ## 1 134 可以明显的看到一个outlier sample.可以手动删除,也可以自动的办法. # clust 1 contains the samples we want to keep. keepSamples = (clust == 1) datExpr = data_exp0[keepSamples,] nGenes = ncol(datExpr) nSamples = nrow(datExpr) datExpr就是我们最终用来进行network分析的表达数据. 下面我们需要读取clinical data. traitData = read.csv(&quot;/Users/shenxt/study/WGCNA_test/ClinicalTraits.csv&quot;) dim(traitData) ## [1] 361 38 names(traitData) ## [1] &quot;X&quot; &quot;Mice&quot; &quot;Number&quot; &quot;Mouse_ID&quot; &quot;Strain&quot; ## [6] &quot;sex&quot; &quot;DOB&quot; &quot;parents&quot; &quot;Western_Diet&quot; &quot;Sac_Date&quot; ## [11] &quot;weight_g&quot; &quot;length_cm&quot; &quot;ab_fat&quot; &quot;other_fat&quot; &quot;total_fat&quot; ## [16] &quot;comments&quot; &quot;X100xfat_weight&quot; &quot;Trigly&quot; &quot;Total_Chol&quot; &quot;HDL_Chol&quot; ## [21] &quot;UC&quot; &quot;FFA&quot; &quot;Glucose&quot; &quot;LDL_plus_VLDL&quot; &quot;MCP_1_phys&quot; ## [26] &quot;Insulin_ug_l&quot; &quot;Glucose_Insulin&quot; &quot;Leptin_pg_ml&quot; &quot;Adiponectin&quot; &quot;Aortic.lesions&quot; ## [31] &quot;Note&quot; &quot;Aneurysm&quot; &quot;Aortic_cal_M&quot; &quot;Aortic_cal_L&quot; &quot;CoronaryArtery_Cal&quot; ## [36] &quot;Myocardial_cal&quot; &quot;BMD_all_limbs&quot; &quot;BMD_femurs_only&quot; # remove columns that hold information we do not need. allTraits = traitData[, -c(31, 16)] allTraits = allTraits[, c(2, 11:36)] dim(allTraits) ## [1] 361 27 names(allTraits) ## [1] &quot;Mice&quot; &quot;weight_g&quot; &quot;length_cm&quot; &quot;ab_fat&quot; &quot;other_fat&quot; ## [6] &quot;total_fat&quot; &quot;X100xfat_weight&quot; &quot;Trigly&quot; &quot;Total_Chol&quot; &quot;HDL_Chol&quot; ## [11] &quot;UC&quot; &quot;FFA&quot; &quot;Glucose&quot; &quot;LDL_plus_VLDL&quot; &quot;MCP_1_phys&quot; ## [16] &quot;Insulin_ug_l&quot; &quot;Glucose_Insulin&quot; &quot;Leptin_pg_ml&quot; &quot;Adiponectin&quot; &quot;Aortic.lesions&quot; ## [21] &quot;Aneurysm&quot; &quot;Aortic_cal_M&quot; &quot;Aortic_cal_L&quot; &quot;CoronaryArtery_Cal&quot; &quot;Myocardial_cal&quot; ## [26] &quot;BMD_all_limbs&quot; &quot;BMD_femurs_only&quot; # Form a data frame analogous to expression data that will hold the clinical traits. femaleSamples = rownames(datExpr) traitRows = match(femaleSamples, allTraits$Mice) datTraits = allTraits[traitRows, -1] rownames(datTraits) = allTraits[traitRows, 1] collectGarbage() 这时候我们得到的datTraits就是clinicaldata,其中行为样品,列为变量. rownames(datTraits) == rownames(datExpr) ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [24] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [47] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [70] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [93] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [116] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE 下面我们来看看样品的临床数据的热图和样品的基因的聚类. # Re-cluster samples sampleTree2 = hclust(dist(datExpr), method = &quot;average&quot;) # Convert traits to a color representation: white means low, red means high, grey means missing entry traitColors = numbers2colors(datTraits, signed = FALSE) # Plot the sample dendrogram and the colors underneath. plotDendroAndColors(sampleTree2, traitColors, groupLabels = names(datTraits), main = &quot;Sample dendrogram and trait heatmap&quot;) 最后,把数据保存下来,准备后续的分析. save(datExpr, datTraits, file = &quot;/Users/shenxt/study/WGCNA_test/FemaleLiver-01-dataInput.RData&quot;) 7.1.2 Network analysis of liver expression data in female mice 数据都准备好之后,下面就是做网络分析和module detection. 首先需要设置R运行环境,主要是要能够进行多线程处理,然后读取数据: enableWGCNAThreads(nThreads = 6) ## Allowing parallel execution with up to 6 working processes. # Load the data saved in the first part lnames = load(file = &quot;/Users/shenxt/study/WGCNA_test/FemaleLiver-01-dataInput.RData&quot;) #The variable lnames contains the names of loaded variables. lnames ## [1] &quot;datExpr&quot; &quot;datTraits&quot; Automatic network construction and module detection 首先需要选择合适的soft-thresholding power 可以使用pickSoftThreshold()函数.一般需要选择一系列candidate powers,然后根据结果进行选择. 注意,这段代码在Rstudio中不能运行,运行出错,需要到R自带IDE或者终端中运行. # Choose a set of soft-thresholding powers powers = c(c(1:10), seq(from = 12, to = 20, by = 2)) # Call the network topology analysis function sft = pickSoftThreshold(datExpr, powerVector = powers, verbose = 5) save(sft, file = &quot;/Users/shenxt/study/WGCNA_test/sft&quot;) load(&quot;/Users/shenxt/study/WGCNA_test/sft&quot;) powers = c(c(1:10), seq(from = 12, to = 20, by = 2)) # Plot the results: sizeGrWindow(9, 5) par(mfrow = c(1, 2)) cex1 = 0.9 # Scale-free topology fit index as a function of the soft-thresholding power plot( sft$fitIndices[, 1], -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2], xlab = &quot;Soft Threshold (power)&quot;, ylab = &quot;Scale Free Topology Model Fit,signed R^2&quot;, type = &quot;n&quot;, main = paste(&quot;Scale independence&quot;) ) text( sft$fitIndices[, 1], -sign(sft$fitIndices[, 3]) * sft$fitIndices[, 2], labels = powers, cex = cex1, col = &quot;red&quot; ) # this line corresponds to using an R^2 cut-off of h abline(h = 0.90, col = &quot;red&quot;) # Mean connectivity as a function of the soft-thresholding power plot( sft$fitIndices[, 1], sft$fitIndices[, 5], xlab = &quot;Soft Threshold (power)&quot;, ylab = &quot;Mean Connectivity&quot;, type = &quot;n&quot;, main = paste(&quot;Mean connectivity&quot;) ) text( sft$fitIndices[, 1], sft$fitIndices[, 5], labels = powers, cex = cex1, col = &quot;red&quot; ) 这里我们选择6. 然后使用blockwiseModules()函数就可以得到modules. net &lt;- blockwiseModules( datExpr, power = 6, TOMType = &quot;unsigned&quot;, minModuleSize = 30, reassignThreshold = 0, mergeCutHeight = 0.25, numericLabels = TRUE, pamRespectsDendro = FALSE, saveTOMs = TRUE, saveTOMFileBase = &quot;femaleMouseTOM&quot;, verbose = 3 ) ## Calculating module eigengenes block-wise from all genes ## Flagging genes and samples with too many missing values... ## ..step 1 ## Cluster size 3600 broken into 2108 1492 ## Cluster size 2108 broken into 1126 982 ## Done cluster 1126 ## Done cluster 982 ## Done cluster 2108 ## Done cluster 1492 ## ..Working on block 1 . ## TOM calculation: adjacency.. ## ..will use 6 parallel threads. ## Fraction of slow calculations: 0.386353 ## ..connectivity.. ## ..matrix multiplication (system BLAS).. ## ..normalization.. ## ..done. ## ..saving TOM for block 1 into file femaleMouseTOM-block.1.RData ## ....clustering.. ## ....detecting modules.. ## ....calculating module eigengenes.. ## ....checking kME in modules.. ## ..removing 1 genes from module 1 because their KME is too low. ## ..removing 1 genes from module 7 because their KME is too low. ## ..removing 1 genes from module 8 because their KME is too low. ## ..removing 1 genes from module 21 because their KME is too low. ## ..merging modules that are too close.. ## mergeCloseModules: Merging modules whose distance is less than 0.25 ## Calculating new MEs... 在这里我们选择了soft thresholding power 6, 然后最小module size设置为30.mergeCutHeight用来控制merge module. 下面看一下分类结果. table(net$colors) ## ## 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## 99 609 460 409 316 312 221 211 157 123 106 100 94 91 77 76 58 47 34 代表这里面有18个module.标记为0的基因代表没有归为任何一类module. # Convert labels to colors for plotting mergedColors = labels2colors(net$colors) # Plot the dendrogram and the module colors underneath plotDendroAndColors( net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]], &quot;Module colors&quot;, dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05 ) 然后将结果保存,用于后续的分析. moduleLabels = net$colors moduleColors = labels2colors(net$colors) MEs = net$MEs geneTree = net$dendrograms[[1]] save(MEs, moduleLabels, moduleColors, geneTree, file = &quot;/Users/shenxt/study/WGCNA_test/FemaleLiver-02-networkConstruction-auto.RData&quot;) 7.1.3 Relating modules to external information and identifying important 首先加载上一步产生的数据: lnames = load(file = &quot;/Users/shenxt/study/WGCNA_test/FemaleLiver-01-dataInput.RData&quot;); #The variable lnames contains the names of loaded variables. lnames ## [1] &quot;datExpr&quot; &quot;datTraits&quot; # Load network data saved in the second part. lnames = load(file = &quot;/Users/shenxt/study/WGCNA_test/FemaleLiver-02-networkConstruction-auto.RData&quot;); lnames ## [1] &quot;MEs&quot; &quot;moduleLabels&quot; &quot;moduleColors&quot; &quot;geneTree&quot; 然后我们想要找到和clinical data关系非常紧密的module.对于每个module的来说,都有一个eigengene,也就是其PCA分析的第一主成分,用来代表该module在每个样品中的含量. # Define numbers of genes and samples nGenes = ncol(datExpr) nSamples = nrow(datExpr) # Recalculate MEs with color labels MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes MEs = orderMEs(MEs0) moduleTraitCor = cor(MEs, datTraits, use = &quot;p&quot;) moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples) # Will display correlations and their p-values textMatrix = paste(signif(moduleTraitCor, 2), &quot;\\n(&quot;, signif(moduleTraitPvalue, 1), &quot;)&quot;, sep = &quot;&quot;); dim(textMatrix) = dim(moduleTraitCor) par(mar = c(6, 8.5, 3, 3)); # Display the correlation values within a heatmap plot labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits), yLabels = names(MEs), ySymbols = names(MEs), colorLabels = FALSE, colors = greenWhiteRed(50), textMatrix = textMatrix, setStdMargins = FALSE, cex.text = 0.5, zlim = c(-1,1), main = paste(&quot;Module-trait relationships&quot;)) ## Warning in greenWhiteRed(50): WGCNA::greenWhiteRed: this palette is not suitable for people ## with green-red color blindness (the most common kind of color blindness). ## Consider using the function blueWhiteRed instead. Gene relationship to trait and important modules: Gene Significance and Module Membership # Define variable weight containing the weight column of datTrait weight = as.data.frame(datTraits$weight_g) names(weight) = &quot;weight&quot; # names (colors) of the modules modNames = substring(names(MEs), 3) geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = &quot;p&quot;)) MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples)) names(geneModuleMembership) = paste(&quot;MM&quot;, modNames, sep=&quot;&quot;) names(MMPvalue) = paste(&quot;p.MM&quot;, modNames, sep=&quot;&quot;) geneTraitSignificance = as.data.frame(cor(datExpr, weight, use = &quot;p&quot;)) GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples)) names(geneTraitSignificance) = paste(&quot;GS.&quot;, names(weight), sep=&quot;&quot;) names(GSPvalue) = paste(&quot;p.GS.&quot;, names(weight), sep=&quot;&quot;) Intramodular analysis: identifying genes with high GS and MM module = &quot;brown&quot; column = match(module, modNames) moduleGenes = moduleColors==module par(mfrow = c(1,1)) verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]), abs(geneTraitSignificance[moduleGenes, 1]), xlab = paste(&quot;Module Membership in&quot;, module, &quot;module&quot;), ylab = &quot;Gene significance for body weight&quot;, main = paste(&quot;Module membership vs. gene significance\\n&quot;), cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module) Summary output of network analysis results head(names(datExpr)) ## [1] &quot;MMT00000044&quot; &quot;MMT00000046&quot; &quot;MMT00000051&quot; &quot;MMT00000076&quot; &quot;MMT00000080&quot; &quot;MMT00000102&quot; head(names(datExpr)[moduleColors==&quot;brown&quot;]) ## [1] &quot;MMT00000887&quot; &quot;MMT00001077&quot; &quot;MMT00001185&quot; &quot;MMT00001486&quot; &quot;MMT00002002&quot; &quot;MMT00002037&quot; annot &lt;- read.csv(file = &quot;/Users/shenxt/study/WGCNA_test/GeneAnnotation.csv&quot;) dim(annot) ## [1] 23388 34 names(annot) ## [1] &quot;X&quot; &quot;ID&quot; &quot;arrayname&quot; &quot;substanceBXH&quot; ## [5] &quot;gene_symbol&quot; &quot;LocusLinkID&quot; &quot;OfficialGeneSymbol&quot; &quot;OfficialGeneName&quot; ## [9] &quot;LocusLinkSymbol&quot; &quot;LocusLinkName&quot; &quot;ProteomeShortDescription&quot; &quot;UnigeneCluster&quot; ## [13] &quot;LocusLinkCode&quot; &quot;ProteomeID&quot; &quot;ProteomeCode&quot; &quot;SwissprotID&quot; ## [17] &quot;OMIMCode&quot; &quot;DirectedTilingPriority&quot; &quot;AlternateSymbols&quot; &quot;AlternateNames&quot; ## [21] &quot;SpeciesID&quot; &quot;cytogeneticLoc&quot; &quot;Organism&quot; &quot;clustername&quot; ## [25] &quot;reporterid&quot; &quot;probeid&quot; &quot;sequenceid&quot; &quot;clusterid&quot; ## [29] &quot;chromosome&quot; &quot;startcoordinate&quot; &quot;endcoordinate&quot; &quot;strand&quot; ## [33] &quot;sequence_3_to_5_prime&quot; &quot;sequence_5_to_3_prime&quot; probes = names(datExpr) probes2annot = match(probes, annot$substanceBXH) # The following is the number or probes without annotation: sum(is.na(probes2annot)) ## [1] 0 # Create the starting data frame geneInfo0 = data.frame(substanceBXH = probes, geneSymbol = annot$gene_symbol[probes2annot], LocusLinkID = annot$LocusLinkID[probes2annot], moduleColor = moduleColors, geneTraitSignificance, GSPvalue) # Order modules by their significance for weight modOrder = order(-abs(cor(MEs, weight, use = &quot;p&quot;))); # Add module membership information in the chosen order for (mod in 1:ncol(geneModuleMembership)) { oldNames = names(geneInfo0) geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]], MMPvalue[, modOrder[mod]]); names(geneInfo0) = c(oldNames, paste(&quot;MM.&quot;, modNames[modOrder[mod]], sep=&quot;&quot;), paste(&quot;p.MM.&quot;, modNames[modOrder[mod]], sep=&quot;&quot;)) } # Order the genes in the geneInfo variable first by module color, then by geneTraitSignificance geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.weight)); geneInfo = geneInfo0[geneOrder, ] write.csv(geneInfo, file = &quot;/Users/shenxt/study/WGCNA_test/geneInfo.csv&quot;) 7.1.4 对module进行分析 在前文中,鉴定出了几个和weight相关的module. Please enable JavaScript to view the comments powered by Disqus. "]
]
